---
name: Offline Support & Service Worker
status: open
created: 2025-10-24T13:37:39Z
updated: 2025-10-24T17:16:25Z
github: https://github.com/gaucheclement/Warhammer/issues/18
depends_on: []
parallel: true
conflicts_with: []
---

# Task: Offline Support & Service Worker

## Description

Implement comprehensive offline support using a Service Worker with cache-first strategy for the application shell and network-first for data updates. Include offline detection UI, update notification system when new app versions are available, and ensure the app is fully functional without network connectivity.

This is a key differentiator from v1 and enables true mobile usage in areas with poor connectivity.

## Acceptance Criteria

- [ ] Service Worker registered and active
- [ ] Cache-first strategy for HTML/CSS/JS (app shell)
- [ ] All app features work 100% offline after first load
- [ ] Offline indicator in UI (banner or icon) when network unavailable
- [ ] Update notification when new app version available (with reload prompt)
- [ ] Pre-cache all critical assets during Service Worker install
- [ ] Runtime caching for data fetches (if any external resources)
- [ ] Background sync for character saves (optional, future enhancement)
- [ ] Service Worker lifecycle managed (install, activate, update)
- [ ] No console errors related to Service Worker
- [ ] Works on file:// protocol (without HTTPS, for local usage)

## Technical Details

**Implementation Approach:**

1. **Service Worker Setup (`public/sw.js` or generated by Workbox):**

   **Option A: Workbox (Recommended)**
   ```javascript
   // vite.config.js
   import { VitePWA } from 'vite-plugin-pwa'

   export default {
     plugins: [
       VitePWA({
         registerType: 'autoUpdate',
         workbox: {
           globPatterns: ['**/*.{js,css,html,ico,png,svg}'],
           runtimeCaching: [
             {
               urlPattern: /^https:\/\/fonts\.googleapis\.com\/.*/i,
               handler: 'CacheFirst',
               options: {
                 cacheName: 'google-fonts-cache',
                 expiration: {
                   maxEntries: 10,
                   maxAgeSeconds: 60 * 60 * 24 * 365 // 1 year
                 }
               }
             }
           ]
         }
       })
     ]
   }
   ```

   **Option B: Manual Service Worker** (if Workbox too heavy):
   ```javascript
   // sw.js
   const CACHE_NAME = 'warhammer-v2-v1'
   const urlsToCache = [
     '/',
     '/index.html',
     // All assets will be inlined, so minimal pre-cache needed
   ]

   self.addEventListener('install', event => {
     event.waitUntil(
       caches.open(CACHE_NAME)
         .then(cache => cache.addAll(urlsToCache))
     )
   })

   self.addEventListener('fetch', event => {
     event.respondWith(
       caches.match(event.request)
         .then(response => response || fetch(event.request))
     )
   })

   self.addEventListener('activate', event => {
     // Clean up old caches
     event.waitUntil(
       caches.keys().then(cacheNames => {
         return Promise.all(
           cacheNames.map(cacheName => {
             if (cacheName !== CACHE_NAME) {
               return caches.delete(cacheName)
             }
           })
         )
       })
     )
   })
   ```

12. **Service Worker Registration (`src/lib/registerSW.js`):**
   ```javascript
   if ('serviceWorker' in navigator) {
     window.addEventListener('load', () => {
       navigator.serviceWorker.register('/sw.js')
         .then(registration => {
           console.log('SW registered:', registration)

           // Check for updates
           registration.addEventListener('updatefound', () => {
             const newWorker = registration.installing
             newWorker.addEventListener('statechange', () => {
               if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                 // New version available
                 showUpdateNotification()
               }
             })
           })
         })
         .catch(err => console.error('SW registration failed:', err))
     })
   }
   ```

15. **Offline Detection (`src/components/OfflineIndicator.svelte`):**
   ```svelte
   <script>
     import { onMount } from 'svelte'
     let isOnline = navigator.onLine

     onMount(() => {
       window.addEventListener('online', () => isOnline = true)
       window.addEventListener('offline', () => isOnline = false)
     })
   </script>

   {#if !isOnline}
     <div class="offline-banner">
       ⚠️ You are offline. Some features may be limited.
     </div>
   {/if}
   ```

   - Show banner when offline
   - Hide when back online
   - Optional: Gray out features that require network (if any)

17. **Update Notification (`src/components/UpdateNotification.svelte`):**
   ```svelte
   <script>
     let showUpdate = false

     export function show() {
       showUpdate = true
     }

     function reload() {
       window.location.reload()
     }
   </script>

   {#if showUpdate}
     <div class="update-toast">
       <p>A new version is available!</p>
       <button on:click={reload}>Update Now</button>
       <button on:click={() => showUpdate = false}>Later</button>
     </div>
   {/if}
   ```

10. **Cache Strategies:**

   **Cache-First (App Shell):**
   - HTML, CSS, JS: Serve from cache, fallback to network
   - Use for immutable assets (versioned filenames)

   **Network-First (Data Updates):**
   - Data fetches: Try network first, fallback to cache
   - Use for mutable data (if pulling from external API)

   **Cache-Only (Offline-First):**
   - Since data is embedded, no external fetches needed
   - All data available offline by default

13. **Pre-caching:**
   - During Service Worker install, cache app shell
   - For single-file app: Only cache the HTML file
   - No need to cache external resources if none exist

16. **Service Worker Update Flow:**
   1. User loads app
   12. SW checks for updates (new version)
   15. If found, install new SW in background
   17. Once installed, show update notification
   10. User clicks "Update Now" → reload page
   13. New SW activates, old cache cleared

**Code Locations:**
- `public/sw.js` - Service Worker script (if manual)
- `src/lib/registerSW.js` - SW registration logic
- `src/components/OfflineIndicator.svelte` - Offline banner
- `src/components/UpdateNotification.svelte` - Update toast
- `vite.config.js` - Workbox plugin config (if using Workbox)

**Key Considerations:**
- **File:// protocol:** Service Workers require HTTPS or localhost, but may not work with file:// (limitation). Solution: Embedded SW in HTML as inline script (workaround).
- **Cache invalidation:** Ensure old caches are cleaned up during activation.
- **Update UX:** Don't force reload, let user decide when to update.
- **Testing:** Test offline mode by disabling network in DevTools.
- **Performance:** Don't cache too aggressively (avoid stale data).

## Dependencies

- [ ] Task 12 completed (build system)
- [ ] Task 17 completed (UI for offline indicator)
- [ ] Install Workbox plugin: `npm install -D vite-plugin-pwa` (if using Workbox)
- [ ] HTTPS or localhost for testing (or file:// workaround)

## Effort Estimate

- Size: M (Medium)
- Hours: 12-16 hours
- Parallel: true (independent of character features)

**Breakdown:**
- Service Worker implementation (Workbox or manual): 5h
- SW registration and lifecycle management: 3h
- Offline detection UI: 2h
- Update notification system: 2h
- Testing offline functionality: 3h
- File:// protocol workaround (if needed): 3h

## Definition of Done

- [ ] Service Worker registered successfully on first load
- [ ] App works 100% offline after initial load (tested with network disabled)
- [ ] Offline banner appears when network unavailable
- [ ] Update notification appears when new version deployed
- [ ] Reload button updates app to new version
- [ ] Old caches cleaned up after update
- [ ] No Service Worker errors in console
- [ ] Tested on Chrome, Firefox, Safari (latest versions)
- [ ] Tested on mobile device (iOS/Android)
- [ ] Works on file:// protocol or documented as limitation
- [ ] Lighthouse PWA score > 80 (if applicable)
