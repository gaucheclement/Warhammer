---
name: Refactor Database ID System for Consistency
status: closed
created: 2025-11-02T10:30:00Z
updated: 2025-11-02T11:37:39Z
github: https://github.com/gaucheclement/Warhammer/issues/47
depends_on: []
parallel: false
conflicts_with: []
priority: high
---

# Task: Refactor Database ID System for Consistency

## Description
Le système actuel d'identification des entités dans la base de données est incohérent et cause des problèmes récurrents lors de chaque nouvelle fonctionnalité. Il existe de multiples façons d'identifier une entité (id, label, index), ce qui crée de la confusion et nécessite des workarounds disgracieux.

## Problèmes Actuels

### 1. Identifiants Multiples et Incohérents
- **ID**: Parfois utilisé, mais pas présent dans le JSON source
- **Label**: Utilisé comme identifiant dans certains contextes
- **Index**: Utilisé pour la navigation, mais non fiable (change si on ajoute des éléments)
- **Nom de table**: Parfois avec 's' au pluriel, parfois sans, avec des exceptions

### 2. Références Relationnelles Complexes
Les relations entre entités ne sont PAS de simples IDs, mais des **références structurées** avec propriétés:

**Exemples réels:**
```
"traits": "Arme +5, Coriace, Intelligent, Lanceur de Sorts (Sorcellerie), Préjugé (sigmarites), Rusé"
```

Décomposition:
- `"Arme +5"` → trait "Arme" + préfixe "+5"
- `"Coriace"` → trait "Coriace" (simple)
- `"Lanceur de Sorts (Sorcellerie)"` → trait "Lanceur de Sorts" + spécialisation "Sorcellerie"
- `"Préjugé (sigmarites)"` → trait "Préjugé" + spécialisation "sigmarites"

**Grammaire des références:**
- Format: `[Préfixe] Label [Suffixe] [(Spécialisation)]`
- Préfixe: modificateurs numériques (+5, -2, etc.)
- Suffixe: peut être du texte additionnel
- Spécialisation: entre parenthèses
- Séparateurs: virgule, "ou", "et"

**Formats actuels:**
- Strings parsées: `"skill1, skill2 ou skill3 et skill4"`
- Avec modificateurs: `"Arme +5, Combat (Épée)"`
- Objets complexes avec propriétés variées
- Arrays hétérogènes (strings, objets, IDs)

### 3. Workarounds Actuels
Le code contient de nombreux workarounds pour gérer cette incohérence:
- `normalizeId()` et fonctions similaires
- Ajout de 's' aux noms d'entités avec des exceptions
- Parsing complexe de listes avec séparateurs multiples
- Conversion entre label/id/index selon le contexte

### 4. Problèmes Spécifiques
- **Navigation par index**: Non fiable car l'index change quand on ajoute des éléments
- **Liens cliquables**: Passent par l'index, ce qui peut pointer vers la mauvaise entité
- **Recherche**: Doit gérer label vs ID vs index
- **Relations "related"**: Utilise un système différent des autres relations

## Solution Proposée

### Phase 1: Audit Complet
1. Documenter toutes les façons dont les entités sont identifiées actuellement
2. Lister tous les endroits où des conversions id/label/index sont faites
3. Identifier toutes les fonctions de normalisation/workaround

### Phase 2: Définir un Standard Cohérent
1. **ID Unique Stable**: Chaque entité doit avoir un ID unique et stable
   - Format: `string` (ex: `"skill-athletisme"`)
   - Généré au chargement du JSON si absent
   - Ne change jamais, même si on réordonne les données

2. **Nom de Table Standard**:
   - Toujours au singulier en base de données
   - Mapper les alias (species → specie, careers → career)
   - Documentation claire des noms canoniques

3. **Références Relationnelles Standard**:
   - **Contrainte**: Le JSON source ne peut pas être modifié (format string avec propriétés)
   - **Solution**: Transformation au chargement dans IndexedDB
   - Dans IndexedDB: stocker au format structuré normalisé
   - Le parsing complexe se fait une seule fois au chargement
   - Le reste du code utilise des objets structurés (jamais de parsing à la volée)

   **Format normalisé dans IndexedDB:**
   ```javascript
   // Au lieu de: "Arme +5, Lanceur de Sorts (Sorcellerie)"
   // Stocker:
   [
     { id: "arme", entityType: "trait", prefix: "+5" },
     { id: "lanceur-de-sorts", entityType: "trait", spec: "Sorcellerie" }
   ]
   ```

   **Structure de référence:**
   ```typescript
   interface EntityReference {
     id: string              // ID stable de l'entité
     entityType: string      // Type (trait, skill, talent, etc.)
     label?: string          // Label original (pour debug)
     prefix?: string         // Modificateur avant (+5, -2, etc.)
     suffix?: string         // Modificateur après
     spec?: string           // Spécialisation entre parenthèses
     rating?: number         // Valeur numérique extraite du préfixe
   }
   ```

### Phase 3: Transformation des Données au Chargement
1. **Au chargement du JSON source** (qui reste inchangé avec strings):
   - Générer des IDs stables pour toutes les entités
   - Parser la grammaire complexe: `[Préfixe] Label [(Spec)]`
   - Extraire: label de base, préfixe, suffixe, spécialisation
   - Résoudre label → ID via lookup
   - Stocker dans IndexedDB au format structuré normalisé

2. **Audit des Duplications de Code** (découvertes importantes):

   **Duplication #1: Parsing de listes par virgules** (répété 12+ fois):
   ```javascript
   // Répété dans db-relations.js lignes: 186, 557, 649, 872, 907, 1184, 1506, 1568
   // Répété dans db-descriptions.js lignes: 474, 579
   // Répété dans validators.js lignes: 246, 420
   .split(',').map(s => s.trim())
   ```

   **Duplication #2: Parsing de specs** (code identique):
   - `parseTalentSpecs()` (db-relations.js:551)
   - `parseSkillSpecs()` (db-relations.js:643)
   - Les deux font **exactement** la même chose

   **Code existant #3: Parsing complexe** (db-descriptions.js:179-182):
   ```javascript
   const regNumber = '( ?[+|-]?\\d+[d\\-+\\d]* ?)?'    // Parse: +5, -2, +1d6
   const regSpec = '( ?\\([^\\(\\$]*\\))?'             // Parse: (Sorcellerie)
   const regexpBegin = isArray ? '(^| ou )' : '...'    // Gère " ou " dans listes
   ```

3. **Solution: Module Mutualisé** - Créer `db-reference-parser.js`:

   ```javascript
   /**
    * Parse comma-separated list into array
    * Replaces 12+ instances of: .split(',').map(s => s.trim())
    */
   export function parseCommaSeparatedList(text) {
     if (!text || typeof text !== 'string') return []
     return text.split(',').map(s => s.trim()).filter(s => s.length > 0)
   }

   /**
    * Parse list with multiple separators (comma, "ou", "et")
    * Example: "skill1, skill2 ou skill3 et skill4"
    */
   export function parseMultiSeparatorList(text) {
     if (!text || typeof text !== 'string') return []
     // Split by comma, "ou", "et"
     return text
       .split(/,| ou | et /)
       .map(s => s.trim())
       .filter(s => s.length > 0)
   }

   /**
    * Parse entity reference with prefix/suffix/spec
    * Example: "Arme +5" → { label: "Arme", prefix: "+5" }
    * Example: "Lanceur de Sorts (Sorcellerie)" → { label: "Lanceur de Sorts", spec: "Sorcellerie" }
    *
    * Réutilise les regex de applyHelp()
    */
   export function parseEntityReference(text) {
     const regNumber = /( ?[+|-]?\d+[d\-+\d]* ?)?/
     const regSpec = /( ?\([^()$]*\))?$/

     let remaining = text.trim()
     let prefix = null
     let suffix = null
     let spec = null

     // Extract prefix (leading number)
     const prefixMatch = remaining.match(/^([+|-]?\d+[d\-+\d]*)\s+/)
     if (prefixMatch) {
       prefix = prefixMatch[1]
       remaining = remaining.substring(prefixMatch[0].length)
     }

     // Extract spec (text in parentheses at end)
     const specMatch = remaining.match(/\(([^()]+)\)$/)
     if (specMatch) {
       spec = specMatch[1]
       remaining = remaining.substring(0, remaining.length - specMatch[0].length).trim()
     }

     // Extract suffix (trailing number)
     const suffixMatch = remaining.match(/\s+([+|-]?\d+[d\-+\d]*)$/)
     if (suffixMatch) {
       suffix = suffixMatch[1]
       remaining = remaining.substring(0, remaining.length - suffixMatch[0].length).trim()
     }

     return {
       label: remaining,
       prefix,
       suffix,
       spec,
       rating: prefix ? parseInt(prefix.replace(/[^\d-]/g, '')) : null
     }
   }

   /**
    * Parse list of entity references
    * Example: "Arme +5, Lanceur de Sorts (Sorcellerie), Coriace"
    * Returns array of EntityReference objects
    */
   export function parseEntityReferenceList(text, entityType) {
     const items = parseMultiSeparatorList(text)
     return items.map(item => {
       const parsed = parseEntityReference(item)
       return {
         ...parsed,
         entityType,
         originalText: item
       }
     })
   }

   /**
    * Parse specs for skills/talents
    * Replaces parseTalentSpecs() and parseSkillSpecs()
    */
   export function parseSpecs(entity, options = {}) {
     if (!entity) return entity

     const parsed = { ...entity }

     if (typeof parsed.specs === 'string' && parsed.specs) {
       parsed.specs = parseCommaSeparatedList(parsed.specs)
       parsed.canHaveSpec = true
       if (options.addSpecName) {
         parsed.specName = 'Au choix'
       }
     } else if (!parsed.specs) {
       parsed.specs = []
       parsed.canHaveSpec = false
       if (options.addSpecName) {
         parsed.specName = ''
       }
     }

     parsed.spec = ''
     parsed.origins = parsed.origins || []

     return parsed
   }
   ```

4. **Refactor des 12+ duplications**:
   - Remplacer toutes les occurrences de `.split(',').map(s => s.trim())` par `parseCommaSeparatedList()`
   - Remplacer `parseTalentSpecs()` par `parseSpecs(talent, { addSpecName: false })`
   - Remplacer `parseSkillSpecs()` par `parseSpecs(skill, { addSpecName: true })`
   - Impact: Suppression de ~50 lignes de code dupliqué

5. **Couche de transformation** (nouveau module):
   - Créer `db-loader.js` qui transforme JSON → IndexedDB
   - Utiliser `db-reference-parser.js` pour tous les parsings
   - Gestion des cas particuliers par type d'entité
   - Résolution label → ID avec validation fuzzy (tolérance aux typos)
   - Logging détaillé:
     - Références non résolues (label introuvable)
     - Ambiguïtés (plusieurs entités avec même label)
     - Formats non reconnus

6. **Validation après chargement**:
   - Vérifier que tous les IDs référencés existent
   - Rapport des références cassées par entité
   - Suggérer des corrections pour les références ambiguës

### Phase 4: Refactor du Code
1. Supprimer toutes les fonctions de normalisation/workaround
2. Utiliser uniquement les IDs pour les relations
3. Supprimer la navigation par index, utiliser les IDs
4. Simplifier les fonctions de recherche/résolution

### Phase 5: Tests et Validation
1. Tests unitaires pour la résolution d'entités par ID
2. Tests d'intégrité référentielle
3. Tests de navigation/liens
4. Validation manuelle sur toutes les entités

## Avantages Attendus

1. **Code Plus Simple**:
   - Suppression de centaines de lignes de workarounds
   - **Suppression de 50+ lignes de code dupliqué** (12+ instances de split/trim)
   - **Fusion de `parseTalentSpecs` et `parseSkillSpecs`** en une fonction unique
   - Parsing complexe centralisé dans un seul module (`db-reference-parser.js`)
   - Le reste du code travaille avec des structures propres

2. **Moins de Bugs**:
   - Une seule façon de parser = moins d'inconsistances
   - Validation centralisée des références
   - Détection précoce des références cassées

3. **Performance**:
   - Parsing fait **une seule fois** au chargement
   - Recherche par ID indexé (pas de parsing à la volée)
   - Pas de regex complexes dans le code métier

4. **Maintenabilité**:
   - Structure de données documentée et typée
   - Nouveaux développeurs comprennent le format
   - Ajout de nouvelles propriétés simplifié

5. **Fiabilité**:
   - Les IDs ne changent pas (navigation stable)
   - Préservation des propriétés (préfixe, spec)
   - Traçabilité (label original conservé pour debug)

6. **Extensibilité**:
   - Facile d'ajouter de nouvelles propriétés aux références
   - Support de nouveaux formats de modificateurs
   - Migration progressive possible (anciens/nouveaux formats coexistent)

## Risques et Mitigation

### Risque: Breaking Changes
**Impact**: Toutes les fonctionnalités existantes peuvent être affectées
**Mitigation**:
- Migration progressive avec tests exhaustifs
- Maintenir une couche de compatibilité temporaire
- Tests de régression complets

### Risque: Parser de Grammaire Complexe
**Impact**: La grammaire des références est complexe et peut avoir des cas edge non documentés
**Exemples de complexité:**
- Préfixes multiples: "Arme +5 +2" ?
- Specs avec parenthèses imbriquées: "Sort (Magie (Feu))" ?
- Formats hybrides: Label avec "ou" ET spécialisation ?
**Mitigation**:
- Audit exhaustif des formats existants dans le JSON
- Tests unitaires couvrant tous les patterns trouvés
- Logging de TOUS les cas non parsés pour analyse
- Mode "fallback" qui préserve la string originale si parsing échoue
- Validation manuelle des 100 premières entités parsées

### Risque: Résolution Label → ID Ambiguë
**Impact**: Plusieurs entités peuvent avoir le même label (homonymes)
**Exemples:**
- "Combat" peut être skill ou talent
- "Feu" peut être lore ou trait
**Mitigation**:
- Contexte typé (chercher d'abord dans le bon entityType)
- Scoring de similarité si pas de match exact
- Logging des ambiguïtés avec suggestions
- Intervention manuelle pour résoudre les cas critiques
- Option: enrichir le JSON source avec hints si nécessaire

### Risque: Performance pendant le Parsing
**Impact**: Parser complexe peut ralentir le chargement initial
**Mitigation**:
- Parser en Web Worker (non-bloquant)
- Progression visible à l'utilisateur
- Cache du résultat parsé (localStorage)
- Réutiliser le cache si JSON source n'a pas changé

## Acceptance Criteria

**Mutualisation du code:**
- [ ] Module `db-reference-parser.js` créé avec fonctions mutualisées
- [ ] Les 12+ instances de `.split(',').map(s => s.trim())` remplacées par `parseCommaSeparatedList()`
- [ ] `parseTalentSpecs()` et `parseSkillSpecs()` remplacées par `parseSpecs()` unique
- [ ] Tests unitaires pour toutes les fonctions de parsing
- [ ] Aucune duplication de logique de parsing dans le code

**Normalisation des données:**
- [ ] Toutes les entités ont un ID unique et stable
- [ ] Toutes les références sont au format `EntityReference` structuré
- [ ] Le JSON source reste inchangé (format string préservé)
- [ ] Transformation au chargement dans `db-loader.js`
- [ ] IndexedDB stocke uniquement le format normalisé (objets structurés)

**Cohérence du système:**
- [ ] Les noms de tables sont cohérents (mapping documenté)
- [ ] Aucune fonction normalizeId ou parsing à la volée dans le code métier
- [ ] Navigation fonctionne uniquement par ID (avec propriétés préservées)
- [ ] Parser gère tous les formats trouvés dans le JSON (audit complet)

**Validation et tests:**
- [ ] Tests d'intégrité référentielle passent à 100%
- [ ] Rapport de parsing liste toutes les références non résolues
- [ ] Performance de recherche améliorée (mesures avant/après)
- [ ] Tests de régression: aucune fonctionnalité cassée

**Documentation:**
- [ ] Documentation du format `EntityReference` et de la grammaire
- [ ] Documentation de `db-reference-parser.js` (API + exemples)
- [ ] Exemples de parsing pour chaque type d'entité
- [ ] Guide de migration pour les développeurs

## Dependencies
- Bloque tous les développements futurs qui touchent aux relations entre entités
- Devrait être fait avant d'ajouter de nouvelles fonctionnalités majeures

## Effort Estimate
- Size: L (Large) - Réduit de XL grâce au code existant réutilisable
- Hours: 55-70 hours (inclut mutualisation du code dupliqué)
  - Phase 1 Audit: 10-12h (documenter formats + identifier 12+ duplications)
  - Phase 2 Design: 6-8h (définir format EntityReference, grammaire déjà définie)
  - Phase 3 Parser mutualisé: 18-22h
    - ✅ Regex déjà testées dans `applyHelp()`
    - Créer `db-reference-parser.js` avec fonctions mutualisées
    - Remplacer 12+ instances de `.split(',').map(s => s.trim())`
    - Fusionner `parseTalentSpecs` et `parseSkillSpecs`
    - Tests unitaires exhaustifs
  - Phase 4 Transformation: 12-16h (db-loader.js + normalisation)
  - Phase 5 Refactor: 8-12h (modifier code utilisant les références)
  - Phase 6 Tests: 8-10h (validation, intégrité, performance)
- Parallel: false (refactor majeur, doit être fait de façon coordonnée)
- Risk: High (touche toute la base de code, mais parsing dérisqué)

**Bénéfices de la mutualisation**:
- Temps additionnel: +5h (refactor des 12 duplications)
- Gain à long terme: Maintenance simplifiée, moins de bugs futurs
- Lignes de code supprimées: ~50-70 lignes

## Definition of Done
- [ ] Audit complet documenté
- [ ] Standard d'ID défini et documenté
- [ ] Script de migration créé et testé
- [ ] Migration des données effectuée
- [ ] Code refactoré (workarounds supprimés)
- [ ] Tests passent (unitaires, intégration, e2e)
- [ ] Performance validée (benchmarks avant/après)
- [ ] Documentation mise à jour
- [ ] Guide de migration pour futures modifications
