---
name: Fix Entity Specialization Display in Descriptions
github: https://github.com/gaucheclement/Warhammer/issues/49
updated: 2025-11-02T18:29:31Z
---

# Issue #49: Fix Entity Specialization Display in Descriptions

**Epic**: Description System
**Priority**: High
**Type**: Bug Fix
**Estimated Effort**: 0.5-1 day

## Problem Statement

Entity specializations are displaying **ALL possible specializations** from the database instead of the **specific specializations** defined in references.

### Examples

In the Wood Elf species "Comps/Talents" tab:

| Current (Wrong) | Expected |
|----------------|----------|
| "Corps à corps (Armes d'hast, À deux mains, Bagarre, Base, Cavalerie, Escrime, Fléau, Parade)" | "Corps à corps (Base)" |
| "Langue (Albionais, Bataille, Bretonnien, Classique, Elthárin, Estalien, Ghassalli, Gospodarin...)" | "Langue (Elthárin)" |
| "Sens aiguisé (Ouïe, Odorat, Goût, Toucher, Vue)" | "Sens aiguisé (Vue)" |

### Impact

- ❌ **User Experience**: Confusing and cluttered displays
- ❌ **Data Accuracy**: Misleading information about race/career abilities
- ❌ **Playability**: Players can't identify which specific specializations their character has
- ⚠️ **Systemic**: Affects all descriptions (species, careers, career levels, classes)

## Root Cause

The code retrieves the **complete entity** from the database with ALL its possible specializations, instead of using the **specific specialization** stored in the reference.

### Data Structure

References can have two formats:

```javascript
// Format 1: Simple string ID (no specific specialization)
species.skills = ["athletisme", "combat"]

// Format 2: Object with ID and specific spec(s)
species.skills = [
  { id: "corps-a-corps", spec: "Base" },
  { id: "langue", specs: ["Elthárin"] },
  { id: "metier", specs: ["Artillerie", "Armurie"] }  // Multiple specs with "ou"
]
```

### Current Code (BROKEN)

**File**: `src/lib/db-descriptions.js:819-824`

```javascript
const skills = await Promise.all(
  species.skills.map(s => {
    const id = typeof s === 'string' ? s : s.id
    return db.skills.get(id)  // ❌ Gets entity with ALL specs from DB
  })
)
```

**Problem**: This retrieves the entity from DB which has ALL possible specs defined globally:

```javascript
// What db.skills.get("corps-a-corps") returns:
{
  id: "corps-a-corps",
  label: "Corps à corps",
  specs: ["Base", "À deux mains", "Armes d'hast", "Bagarre", "Cavalerie", ...]  // ALL
}

// What we need:
{
  id: "corps-a-corps",
  label: "Corps à corps",
  specs: ["Base"]  // Only the race-specific one
}
```

### Display Logic

**File**: `src/lib/db-relations.js:1884-1909` - `getEntityLabel()`

```javascript
// Add specialization
let spec = ''
if (entity.specs && Array.isArray(entity.specs) && entity.specs.length > 0) {
  spec = ` (${entity.specs.join(' ou ')})`  // Displays ALL specs
} else if (typeof entity.specs === 'string' && entity.specs) {
  spec = ` (${entity.specs})`
} else if (entity.spec) {
  spec = ` (${entity.spec})`
}
```

The display logic is correct, but it receives an entity with ALL specs instead of the filtered ones.

## Affected Code Locations

This pattern exists in **6 locations** across 2 files:

### `src/lib/db-descriptions.js`

1. **Lines 819-826**: Species skills
   ```javascript
   species.skills.map(s => db.skills.get(id))
   ```

2. **Lines 832-839**: Species talents
   ```javascript
   species.talents.map(t => db.talents.get(id))
   ```

3. **Lines 759-767**: Class trappings
   ```javascript
   classObj.trappings.map(t => db.trappings.get(id))
   ```

### `src/lib/db-relations.js`

4. **Lines 273-280**: `getCareerLevelSkills()`
   ```javascript
   allSkills.map(skillId => db.skills.get(id))
   ```

5. **Lines 311-316**: `getCareerLevelTalents()`
   ```javascript
   talentIds.map(talentId => db.talents.get(id))
   ```

6. **Lines 421-429**: `getCareerLevelTrappings()`
   ```javascript
   allTrappings.map(trappingId => db.trappings.get(id))
   ```

## Proposed Solution

Create a **utility function** `resolveEntityReference()` in `db-relations.js` to properly resolve references with their specific specializations.

### Function Implementation

**File**: `src/lib/db-relations.js`

```javascript
/**
 * Resolve an entity reference with specific specializations
 *
 * When entities are referenced (e.g., a race has "Corps à corps (Base)"),
 * the reference stores the specific specialization. This function retrieves
 * the entity from the database and applies the reference-specific specs,
 * overriding the entity's full spec list.
 *
 * @param {string|Object} reference - Reference (string ID or {id, spec/specs})
 * @param {Object} dbCollection - Database collection (db.skills, db.talents, etc.)
 * @returns {Promise<Object|null>} Entity with reference specs applied
 *
 * @example
 * // Simple reference (no specific spec)
 * await resolveEntityReference("athletisme", db.skills)
 * // Returns entity as-is with all possible specs
 *
 * @example
 * // Reference with single spec
 * await resolveEntityReference({ id: "corps-a-corps", spec: "Base" }, db.skills)
 * // Returns entity with specs = ["Base"] only
 *
 * @example
 * // Reference with multiple specs
 * await resolveEntityReference({ id: "metier", specs: ["Artillerie", "Armurie"] }, db.skills)
 * // Returns entity with specs = ["Artillerie", "Armurie"]
 */
export async function resolveEntityReference(reference, dbCollection) {
  if (!reference) return null

  // Get the ID
  const id = typeof reference === 'string' ? reference : reference.id
  if (!id) return null

  // Fetch entity from DB
  const entity = await dbCollection.get(id)
  if (!entity) return null

  // If reference is just a string, return entity as-is (all specs)
  if (typeof reference === 'string') {
    return entity
  }

  // Apply reference-specific specs
  const result = { ...entity }

  if (reference.specs) {
    // Reference has specific specs (can be array or string)
    result.specs = Array.isArray(reference.specs)
      ? reference.specs
      : [reference.specs]
    result.spec = result.specs[0] || ''
  } else if (reference.spec) {
    // Reference has a single spec
    result.spec = reference.spec
    result.specs = [reference.spec]
  }
  // If neither specs nor spec exist in reference, keep entity's original specs

  return result
}
```

### Usage Examples

**Before (broken):**

```javascript
const skills = await Promise.all(
  species.skills.map(s => {
    const id = typeof s === 'string' ? s : s.id
    return db.skills.get(id)  // ❌ Wrong
  })
)
```

**After (fixed):**

```javascript
const skills = await Promise.all(
  species.skills.map(s => resolveEntityReference(s, db.skills))
)
```

## Implementation Streams

### Stream A: Create Utility Function (Priority: Critical)

**Goal**: Implement `resolveEntityReference()` with tests

**Tasks**:
1. Add `resolveEntityReference()` to `src/lib/db-relations.js`
2. Export the function
3. Add JSDoc documentation
4. Create unit tests in `src/lib/__tests__/db-relations.test.js`

**Test Cases**:
```javascript
describe('resolveEntityReference', () => {
  it('should return null for null/undefined reference', async () => {
    expect(await resolveEntityReference(null, db.skills)).toBeNull()
    expect(await resolveEntityReference(undefined, db.skills)).toBeNull()
  })

  it('should return entity as-is for string reference', async () => {
    const result = await resolveEntityReference("athletisme", db.skills)
    expect(result.specs).toEqual(/* all possible specs */)
  })

  it('should apply single spec from reference', async () => {
    const result = await resolveEntityReference(
      { id: "corps-a-corps", spec: "Base" },
      db.skills
    )
    expect(result.specs).toEqual(["Base"])
    expect(result.spec).toBe("Base")
  })

  it('should apply multiple specs from reference', async () => {
    const result = await resolveEntityReference(
      { id: "metier", specs: ["Artillerie", "Armurie"] },
      db.skills
    )
    expect(result.specs).toEqual(["Artillerie", "Armurie"])
    expect(result.spec).toBe("Artillerie")
  })

  it('should handle specs as string', async () => {
    const result = await resolveEntityReference(
      { id: "langue", specs: "Elthárin" },
      db.skills
    )
    expect(result.specs).toEqual(["Elthárin"])
  })
})
```

**Acceptance Criteria**:
- ✅ Function implemented with full JSDoc
- ✅ All test cases pass
- ✅ Handles all reference formats (string, {id}, {id, spec}, {id, specs})
- ✅ Edge cases covered (null, undefined, empty specs)

**Files Modified**:
- `src/lib/db-relations.js`
- `src/lib/__tests__/db-relations.test.js`

---

### Stream B: Fix db-descriptions.js (Priority: High)

**Goal**: Replace all broken entity resolution in descriptions

**Tasks**:
1. Import `resolveEntityReference` in `db-descriptions.js`
2. Fix species skills (line 819-826)
3. Fix species talents (line 832-839)
4. Fix class trappings (line 759-767)
5. Test with Wood Elf species

**Changes**:

**Location 1**: Species Skills (lines 819-826)
```javascript
// OLD
const skills = await Promise.all(
  species.skills.map(s => {
    const id = typeof s === 'string' ? s : s.id
    return db.skills.get(id)
  })
)

// NEW
const skills = await Promise.all(
  species.skills.map(s => resolveEntityReference(s, db.skills))
)
```

**Location 2**: Species Talents (lines 832-839)
```javascript
// OLD
const talents = await Promise.all(
  species.talents.map(t => {
    const id = typeof t === 'string' ? t : t.id
    return db.talents.get(id)
  })
)

// NEW
const talents = await Promise.all(
  species.talents.map(t => resolveEntityReference(t, db.talents))
)
```

**Location 3**: Class Trappings (lines 759-767)
```javascript
// OLD
const trappings = await Promise.all(
  classObj.trappings.map(t => {
    const id = typeof t === 'string' ? t : t.id
    return db.trappings.get(id)
  })
)

// NEW
const trappings = await Promise.all(
  classObj.trappings.map(t => resolveEntityReference(t, db.trappings))
)
```

**Acceptance Criteria**:
- ✅ All 3 locations updated to use `resolveEntityReference`
- ✅ Wood Elf shows "Corps à corps (Base)" not all specs
- ✅ Wood Elf shows "Langue (Elthárin)" not all languages
- ✅ No regressions in other species/classes

**Files Modified**:
- `src/lib/db-descriptions.js`

---

### Stream C: Fix db-relations.js Functions (Priority: High)

**Goal**: Fix entity resolution in career level helper functions

**Tasks**:
1. Fix `getCareerLevelSkills()` (line 273-280)
2. Fix `getCareerLevelTalents()` (line 311-316)
3. Fix `getCareerLevelTrappings()` (line 421-429)
4. Test with a career that has specific specs

**Changes**:

**Location 1**: `getCareerLevelSkills()` (lines 273-280)
```javascript
// OLD
const skillObjects = await Promise.all(
  allSkills.map(skillId => {
    const id = typeof skillId === 'string' ? skillId : skillId.id
    return db.skills.get(id)
  })
)

// NEW
const skillObjects = await Promise.all(
  allSkills.map(skillId => resolveEntityReference(skillId, db.skills))
)
```

**Location 2**: `getCareerLevelTalents()` (lines 311-316)
```javascript
// OLD
const talentObjects = await Promise.all(
  talentIds.map(talentId => {
    const id = typeof talentId === 'string' ? talentId : talentId.id
    return db.talents.get(id)
  })
)

// NEW
const talentObjects = await Promise.all(
  talentIds.map(talentId => resolveEntityReference(talentId, db.talents))
)
```

**Location 3**: `getCareerLevelTrappings()` (lines 421-429)
```javascript
// OLD
const trappingObjects = await Promise.all(
  allTrappings.map(trappingId => {
    const id = typeof trappingId === 'string' ? trappingId : trappingId.id
    return db.trappings.get(id)
  })
)

// NEW
const trappingObjects = await Promise.all(
  allTrappings.map(trappingId => resolveEntityReference(trappingId, db.trappings))
)
```

**Acceptance Criteria**:
- ✅ All 3 functions updated
- ✅ Career levels show correct specific specs
- ✅ No regressions in career displays

**Files Modified**:
- `src/lib/db-relations.js`

---

### Stream D: Testing and Validation (Priority: Medium)

**Goal**: Comprehensive testing of the fix

**Tasks**:
1. Unit tests for `resolveEntityReference()` (in Stream A)
2. Integration tests for description generation
3. Manual testing checklist
4. Performance testing (ensure no slowdown)

**Manual Testing Checklist**:

- [ ] **Wood Elf Species**:
  - [ ] "Corps à corps (Base)" - not all specs
  - [ ] "Langue (Elthárin)" - not all languages
  - [ ] "Discrétion (Rurale)" - not all types
  - [ ] "Projectiles (Arc)" - not all types
  - [ ] "Sens aiguisé (Vue)" - not all senses

- [ ] **Other Species**:
  - [ ] Human skills display correctly
  - [ ] Dwarf skills display correctly
  - [ ] Halfling skills display correctly

- [ ] **Career Levels**:
  - [ ] Career level skills show specific specs
  - [ ] Career level talents show specific specs
  - [ ] Career level trappings show specific specs

- [ ] **Classes**:
  - [ ] Class trappings display correctly

- [ ] **Edge Cases**:
  - [ ] Skills without specs (no parentheses)
  - [ ] Skills with multiple specs ("ou" separator)
  - [ ] Empty/null references don't crash

**Acceptance Criteria**:
- ✅ All manual tests pass
- ✅ No console errors
- ✅ No performance regression
- ✅ All unit tests pass

**Files Created**:
- Manual test results documented in updates folder

---

## Testing Strategy

### Unit Tests

**File**: `src/lib/__tests__/db-relations.test.js`

- Test all reference formats
- Test edge cases (null, undefined, empty)
- Test spec array vs string handling
- Test entity not found in DB

### Integration Tests

**File**: `src/lib/__tests__/db-descriptions.test.js`

- Test `generateSpeciesDescription()` with Wood Elf
- Verify skills display only race-specific specs
- Verify talents display only race-specific specs
- Test career descriptions with specific specs

### Manual Testing

1. Clear browser cache and reload
2. Navigate to Wood Elf in Creator
3. Check "Comps/Talents" tab
4. Verify each skill/talent shows only specific specs
5. Test with multiple species/careers

### Performance Testing

- Benchmark description generation before/after
- Ensure no slowdown (should be same or faster)
- Profile with Chrome DevTools

## Risks and Mitigation

| Risk | Likelihood | Impact | Mitigation |
|------|-----------|--------|------------|
| Breaking existing displays without specs | Low | Medium | Test all entity types, handle string references |
| Performance impact from extra function calls | Very Low | Low | Function is lightweight, same DB calls |
| Missing edge cases in spec formats | Medium | Low | Comprehensive unit tests |
| Regressions in career/class displays | Low | Medium | Full manual testing checklist |

## Success Metrics

- ✅ Wood Elf "Corps à corps" shows "(Base)" only
- ✅ Wood Elf "Langue" shows "(Elthárin)" only
- ✅ All 6 affected locations fixed
- ✅ All unit tests pass
- ✅ No console errors
- ✅ Manual testing checklist 100% complete
- ✅ Zero performance regression

## Dependencies

**Blocks**:
- Better user experience in character creation
- Accurate data display

**Blocked By**:
- None

**Related Issues**:
- None (isolated bug fix)

## Rollback Plan

If critical issues arise:

1. Revert changes to `db-descriptions.js` and `db-relations.js`
2. Remove `resolveEntityReference()` function
3. Redeploy previous version
4. Database structure unchanged, so no data migration needed

## Notes

- This is a **focused bug fix** with clear scope
- The solution is **non-breaking** - maintains backward compatibility
- The utility function is **reusable** for future entity resolution needs
- Low risk, high value fix

## Timeline

- **Stream A** (Utility Function): 2 hours
- **Stream B** (db-descriptions.js): 1 hour
- **Stream C** (db-relations.js): 1 hour
- **Stream D** (Testing): 2 hours
- **Total**: 6 hours (0.75 days)

---

**Created**: 2025-11-02
**Status**: Ready for Implementation
**Assignee**: TBD
